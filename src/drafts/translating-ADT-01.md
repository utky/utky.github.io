------------------
title: 代数的データ型へと翻訳する#01
date: 2015-10-19
tags: [haskell, functional programming]
------------------

はじめに
=====

Haskellはその豊かな型システムを用いることで強力な表現力を獲得しています。
でもその表現力を使いこなすためは、私たちもいくばくかのスキルをつけなければなりません。

その中でもいま私が一番重要だと考えているのが、

*問題を代数的データ型で表現するスキル*

です。

このスキルが不十分だとデータ型を関数上で扱うときに不必要なboiler plateが多発したり、
必要な拡張ができなくなったり、最悪解決したい問題すら解決できません。


*Haskellにおいてはデータ型の設計は生命線なのです。*


この記事ではいま私自身が直面している問題領域を代数的データ型へと
翻訳していく過程を記します。

そしてその途中では練習と称してよく見かける問題も代数的データ型へと翻訳してみようと思います。

翻訳という考え方は最近読んでいる新井紀子さんの名著『[数学は言葉](http://www.amazon.co.jp/dp/4489020538)』からインスパイアされました。
言葉で表された問題を分析して数式に翻訳していく営みが美しいと感じました。
同じことがHaskellのADT（代数的データ型）でもできるのではないかと思っています。

問題をよりよいデータ型で表現したいです。
ただそれだけです。

問題の発見
==========

Sqliteのデータベースへデータ登録を行ったり、
ファイルシステムとのIOを行ったりするようなCLIをもつアプリケーションを作っています。

[lycopene](https://github.com/utky/lycopene)

サーバを立ち上げずに軽くBacklogの管理をしたいな、と思ったのがきっかけで作り始めました。
しかしDBとのIOの絡んだテストコードでは、思うように結果セットからデータを引き出せないなど
数々の問題に直面することになりました。

その時の問題の切り分けのしにくさに我がコードながら辟易し始めました。

よかれと思って書いた自分のコードのデータ設計は本当に正しいのだろうか？

一時期調子に乗ってFreeモナドを導入したあたりで何かシンプルで良いものが失われた気がしました。


問題領域をよく表現した見通しのよいデータ型で再設計をし、
スマートに目的を達成するのが実は一番近道なのだと思うようになりました。

見通しのよいデータ型を設計するためにも、
関心を持った問題領域を代数的データ型（ADT）へと翻訳していくのが良さそうだとあたりをつけました。

ここからは言葉とADTの変換を中心に書いていこうと思います。


ドメイン
--------

今回作りたいアプリケーションではBacklog管理と時間計測を行いたいと考えています。
まずは解決するべき問題であるドメインの整理から始めます。

ドメインはデータベース技術やユーザインタフェースに依存せず純粋に
保たれなければいけないため、何より最初に設計を始められる部分でもあります。
逆にデータベースとの接続や外部API呼び出しを考慮しなければいけないような場面に出くわした場合、
それはドメインを純粋に保てていない危険信号と捉えるべきです。

まずはBacklogの構成要素となるユーザーストーリーに相当する`Issue`、
そして`Issue`に対してとりかかった作業の実績時間`TimeTrack`を定義します。


```haskell
IssueとTimeTrackを入れる
```

これらのデータ型は値を格納することを目的としたデータコンテナの一種です。
計算の振る舞いに関する記述は持ちません。

ただ名詞として表現された概念の属性を一覧化しているだけです。
こういうのはユースケースを検討初期に自ずと解ってくることが多いので、
定義が必要であることはすぐに発見できます。


難しいのは出来事や振る舞いをよく観察することで見つかるような、
「計算の性質、制約、条件」を表すデータ型です。

例） ...

一方でドメイン内で起こった変更が永続化されるべきであることを、
ドメイン外部へ伝えるためのインタフェースが必要です。

### あるデータを永続化できることを表すデータ型

E = f(x) -- f(x)はエンティティ
∀x. (x → E) → 

```haskell
Store, Persist, Fetchあたりを記述する
```

イベント
--------

静的なデータモデル、永続化にまつわる計算の性質。
これでドメインは充分か考えます。

上記で示したProjectやSprint, Issueにはライフサイクルがあります。
ライフサイクルとはあるデータがある瞬間にとりうる状態の段階です。
外部からイベントやアクションを受信した時に状態は次の段階に遷移します。

イベントの受信とライフサイクルの状態遷移を定義できないでしょうか。

まずはイベントと状態の遷移を図式化してみます。
例としてIssueのライフサイクルを記述します。

```
図が入る
```

この図から発見できた状態を`IssueState`というデータ型で表現してみます。


```
IssueState
```

これは状態遷移図でいう長方形の箱に相当します。

次に各箱への遷移を促すイベント/アクションについて定義します。
対象としているデータに対して何が起きうるか、どんなときに状態が変わるか、
といった「変化のきっかけ」を書き下すようにします。

```
IssueEvent
```

クエリ（問い合わせ）
-------------------

ここまで状態の記述と遷移についてデータ型を用いて表現しましたが、
他にもできなければならないことがあります。

データの問い合わせです。
これは状態遷移とは関係の無い操作であるため、イベントとして表現するのは適切ではありません。
問い合わせはデータを変更してはいけません。

クエリを言葉にするとどう表現できるでしょう。

*"パラメータpを条件にrをドメインから取り出す"*

でしょうか。

### クエリの定義

∀r∈ドメイン ∀p. Q(p, r)

### 定義のADT訳


アプリケーション層
-----------------

イベントと状態を記述できたことにより、
あるデータを変更したい場合はイベントを作成してドメインへと送り込めば良い、という規則が見えてきました。
逆に言うとそれ以外はできません。

これは強力な制約です。
