------------------
title: 代数的データ型へと翻訳する
date: 2015-10-19
tags: [haskell, functional programming]
------------------

はじめに
=====

Haskellはその強力な型システムを用いることで豊かな表現力を獲得しています。

でも私はその型システムを使いこなせていないと感じることがよくあります。

少し前に自分が書いたHaskellのコード読み返した時に、
そのコードがしようとしていることを読み取るのに時間がかかってしまいます。

何が問題なのか考えた結果解ったのは、
「型注釈で表現している以上のことを関数の定義内でやろうとしている」
ということでした。

逆に言えば型として表現されるべき条件がまったく型注釈にあらわれていないのです。
ほとんどの関数で結局定義を見に行くしかなくなってストレスが溜まっていきます。

この経験を踏まえて重要だと考えたのは

*問題を代数的データ型で表現するスキル*

です。


----- 

FIXME: ここは消すかも

オブジェクト指向プログラミング言語でコードを書いていた時は、
名詞的な概念をクラスとして定義し動詞的な振る舞いをそのクラスのメソッドとして定義するように心がけていました。

```java

```

Haskellを始めたあともこの発想がなかなか抜けず下記のように、
名詞的な概念をデータとして定義し、動詞的な振る舞いを関数として定義していました。

```
data Foo = MkFoo Int

changeFoo
saveFoo

```

-----


Haskellにおいてはデータ型の設計は生命線であって、
これを蔑ろにしたままHaskellコードを書き続けるのは難しいと思うようになりました。
(もちろん私がもっとコード読解力に秀でていればこうは言わなかったかもしれません)

## 代数データ型設計のステップアップ

この記事ではいま私自身が直面している問題を代数的データ型へと翻訳していく過程を記します。

そしてその途中では練習と称してよく見かける問題も代数的データ型へと翻訳してみようと思います。

翻訳という考え方は最近読んでいる新井紀子さんの著作『[数学は言葉](http://www.amazon.co.jp/dp/4489020538)』からインスパイアされました。
日本語で表された問題を分析して数式に翻訳していくという営みがとても美しいと感じました。
同じことがHaskellのADT（代数的データ型）でもできるのではないかと思っています。

根本にあるのは「よく設計された豊富なデータ型といくつかの関数で問題を解きたい」という気持ちです。

問題の発見
==========

SQLiteのデータベースへデータ登録を行ったり、
ファイルシステムとのIOを行ったりするようなCLIをもつ[lycopene](https://github.com/utky/lycopene)というアプリケーションを作っています。

サーバを立ち上げずに軽くBacklogの管理をしたいな、と思ったのがきっかけで作り始めました。
しかしDBとのIOの絡んだテストコードでは、思うように結果セットからデータを引き出せないなど
数々の問題に直面することになりました。

IOと絡みあったコードはデバッグの難易度を上げることを痛感しました。
純粋さは実践の上でも極めて重要な性質でした。

こうしたIO関連の問題の切り分けのしにくさに我がコードながら辟易し始めました。

- よかれと思って書いた自分のコードのデータ設計は本当に正しいのだろうか？
- 調子にのってFreeモナドを導入したけれどかえって複雑になっていないか？
- 本当に直截的に問題を表せているだろうか？

問題をよく表現した見通しのよい代数的データ型で再設計をし、
スマートに目的を達成するのが実は一番近道なのだと思うようになりました。

見通しのよいデータ型を設計するためにも、
関心を持った問題を代数的データ型（ADT）へと翻訳していくのが良さそうだとあたりをつけました。

今回は特に表現方法に苦労している「データベースアクセス」にフォーカスして定義作業を進めてみようと思います。
ここからは言葉とADTの変換を中心に書いていこうと思います。

進め方
=========

問題を解決するにあたり*ADT訳*という手続きを導入したいと思います。
これは問題を表す自然言語の記述を代数的データ型(ADT)で表現しなおすということです。

`自然言語での問題の定義 → 代数的データ型の定義`

のように日本語で書いた問題がHaskellのソースコードに変換できれば完了です。

特に最初のうちは問題を形式的に表す練習を兼ねて、下記のようなステップで翻訳を実施していきます。

1. 日本語での定義
2. 論理式での定義 (数学的な表現)
3. 代数的データ型での定義 (プログラム的な表現)

このやり方が迂遠であったり誤っていたりするかもしれません。
でもこれでやってみたいのです。自分の勉強のために。

ドメイン
--------

今回作りたいアプリケーションではBacklog管理と時間計測を行いたいと考えています。
まずは解決するべき問題であるドメインの整理から始めます。

ドメインはデータベース技術やユーザインタフェースに依存せず純粋に
保たれなければいけないため、何より最初に設計を始められる部分でもあります。
逆にデータベースとの接続や外部API呼び出しを考慮しなければいけないような場面に出くわした場合、
それはドメインを純粋に保てていない危険信号と捉えるべきです。

まずはBacklogの構成要素となるユーザーストーリーに相当する`Issue`、
そして`Issue`に対してとりかかった作業の実績時間`TimeTrack`を定義します。


```haskell
IssueとTimeTrackを入れる
```

これらのデータ型は値を格納することを目的としたデータコンテナの一種です。
計算の振る舞いに関する記述は持ちません。

ただ名詞として表現された概念の属性を一覧化しているだけです。
こうした概念はユースケースの検討初期に自ずと解ってくることが多いので、
定義が必要であることはすぐに発見できます。


難しいのは出来事や振る舞いをよく観察することで見つかるような、
「計算の性質、制約、条件」を表すデータ型です。

例） ...

例えばドメイン内で起こった変更が永続化されるべきであることを、
ドメイン外部へ伝えるためのデータ型が必要です。

他にもあるストレージからデータの集合をまとめて取り出して計算することもあります。
ドメイン外部へとデータの入力を要求するデータ型も必要です。

データベース
------------

### 何を表したいのか

データベースに関してドメイン内で起こりうるできごとを整理しましょう。

- あるデータを永続化機構に保存する。
- あるデータを永続化機構から取り寄せてそれをもとに計算を行う。

### 概念に名前を

登場した概念に名前をつけていきます。この名前に基づいて型が定義されていきます。

- あるデータをドメイン外部へ保存することを`Persist`と呼ぶことにします。
- あるデータをドメイン外部から取り寄せて計算することを`Fetch`と呼ぶことにします。

`Persist`は外部へデータ保存を通知するための命令です。
`Fetch`も同様に外部へとデータの入力を要求するための命令です。

このあたりは外部へとデータを印字する`print`のような機能と、
外部からの入力を待ち受ける`readline`のような機能とよく似ていることに気づくと
そんなに難しくなさそうに見えますね。

ドメインだけを記述するならこれで充分でしょう。

しかし気になることが残ります。
「永続化機構」という単語が二回もでてきており、どうやら名前づけが必要そうです。
けれどドメインはこの永続化機構について感知するべきではありません。
ドメインは永続化機構が存在することすら知りません。ただ外部に命令を発するだけです。
この「永続化機構」はドメインにいてはいけない概念です。

一方でドメインからの命令を実行に移す別の仕組みは「何が永続化機構か」を知っている必要がありそうなので、
やはり後々名前付けが必要になるでしょう。
ここでは`Store`と名づけておきます。

### Persistの定義と性質

`Persist`の性質について下記のように記述します。

`Persist(a)`は...

1. `a`を永続化する抽象的な命令を表します。
2. `a`は処理系`Store`が永続化するためのデータ形式に変換可能である。

2の性質は`Store`というドメインの外にいる登場人物が関係するため、
考慮から外した方が良さそうです。

### Persistの数訳

任意の`a`について永続化の命令を適用できる。

\\(
\\forall a Persist(a)
\\)

特になんの制約もありません。保存しろ、という指示だけです。

ほんまか……？
精々`Store`がこの命令を処理する際に`a`が何らかの保存用データ形式に
変換できるルールの定義が必要ですがあとで考えても大丈夫そうです。

かなり怪しいですがいったんこれでいきます。

### PersistのADT訳

```haskell
a -> Persist a
```

ほんとか……ほんとにこれでいいのか？

なんかもっとこうそれっぽい制約とかを表現しなくていいのか？

あーでも、このデータを保存したい。どうやってするかは問わない（キリッ）っていうデータを表していると思えば別にこれでもいいのかな。


### Fetchの定義と性質

`Fetch`の性質について下記のように記述します。

`Fetch(a, b)`は...

1. 外部へと`a`を入力して`b`を受け取る要求を表します。

外部をブラックボックスとみなした時にFetchはちょうど関数の働きをします。

### Fetchの数訳

\\(
\\forall a, \\forall b Fetch(a, b)
\\)

### FetchのADT訳

```haskell
p -> Fetch p r
```


```haskell
TODO: Store, Persist, Fetchあたりを記述する
```


### Entityの定義と性質

`Entity`の性質について下記のように記述します。

`Entity(k, a)`は...

1. 一意に識別するインデックス`k`に対応づけられます。(一意性)
2. 対応するリポジトリに保存できます。
3. インデックスを使ってリポジトリから取り出すことができます。
4. リポジトリがサポートするI/Fを用いて複数件とりだせます。

### Repositoryの定義と性質

`Repository a`は...

1. `a`の集合を表します。
2. 各元`a`は識別子`k`を用いて取り出すことができます。
3. TODO: 


イベント
--------

これまで静的なデータモデル、永続化にまつわる計算の性質について考えてきました。
これでドメインは充分か考えます。

上記で示したProjectやSprint, Issueにはライフサイクルがあります。
ライフサイクルとはあるデータがある瞬間にとりうる状態の段階です。
外部からイベントやアクションを受信した時に状態は次の段階に遷移します。

イベントの受信とライフサイクルの状態遷移を定義できないでしょうか。

まずはイベントと状態の遷移を図式化してみます。
例としてIssueのライフサイクルを記述します。

```
図が入る
```

この図から発見できた状態を`IssueState`というデータ型で表現してみます。


```
TODO: IssueState
```

これは状態遷移図でいう長方形の箱に相当します。

次に各箱への遷移を促すイベント/アクションについて定義します。
対象としているデータに対して何が起きうるか、どんなときに状態が変わるか、
といった「変化のきっかけ」を書き下すようにします。

```
TODO: IssueEvent
```

クエリ（問い合わせ）
-------------------

ここまで状態の記述と遷移についてデータ型を用いて表現しましたが、
他にもできなければならないことがあります。

データの問い合わせです。
これは状態遷移とは関係の無い操作であるため、イベントとして表現するのは適切ではありません。
問い合わせはデータを変更してはいけません。

クエリを言葉にするとどう表現できるでしょう。

*"パラメータpを条件にrをドメインから取り出す"*

でしょうか。

### クエリの定義

TODO: ∀r∈ドメイン ∀p. Q(p, r)

### 定義のADT訳

TODO: 


アプリケーション層
-----------------

イベントと状態を記述できたことにより、
あるデータを変更したい場合はイベントを作成してドメインへと送り込めば良い、という規則が見えてきました。
逆に言うとそれ以外はできません。

これは強力な制約です。

TODO: 
