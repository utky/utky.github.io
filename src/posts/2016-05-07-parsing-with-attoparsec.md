------------------
title: ネットワークからのフレームをAttoparsecで解析する (WIP)
date: 2016-04-18
tags: [network, haskell]
------------------

## はじめに

ネットワークから入力されたネットワークプロトコルのフレームを解析して
処理するようなことが仕事柄よく必要になります。

ここで想定しているネットワーク・プロトコルとは

- OpenFlow
- BGP (Border Gateway Protocol)
- LDP (Label Distribution Protocol)

などです。

主にL4のTCPやUDP上で動作するネットワーク制御プロトコルのことを指します。

SMTPやHTTPなどを期待されている方、ごめんなさい。
ここではネットワークの*制御*にフォーカスしたプロトコルしか言及しません。

この手のプロトコルは多くの場合、固定長フォーマット+可変長TLVフォーマットで構成されています。
いずれにしてもJSONのように`{}`や`[]`など識別子を頼りに解析をするのではなく、
フィールドの長さを頼りにバイナリデータを解析します。

市井のAttoparsecベースのparserを見ていると、フィールドの長さをベースにデータ解析をおこなう例が少ないです。
多くの場合HTTPやJSON, SMTP, LDAPなどテキストから識別子を解析するプロトコルの実装です。
固定長+可変長TLVフォーマットのフレーム解析はニーズが少ないせいか見かけません。
ここではそうした固定長+可変長TLVフォーマットのフレーム解析にAttoparsecを使う上でのポイントを記しておきたいと思います。

Javaのネットワークライブラリである
[Netty](http://netty.io/)
にはこういうかゆいところに手が届く
[API](http://netty.io/4.0/api/io/netty/handler/codec/LengthFieldBasedFrameDecoder.html)
があるんですよね。Nettyの成熟っぷりが凄まじい。

## ゴール

OpenFlowのEchoRequestメッセージの解析をゴールとします。

OpenFlowのハンドシェークシーケンスでは通常Helloメッセージの送受信が先にくるのですが、
Helloはいつの間にか複雑になっていたので、あとに回します。

## OpenFlow

OpenFlowはネットワークパケットが持つ様々なヘッダ情報をもとに「フロー」として分類し、
フロー単位にスイッチングを行うOpenFlowスイッチを制御するためのプロトコルです。
OpenFlowスイッチを制御するためのアプリケーションをOpenFlowコントローラと呼びます。

### フレームフォーマット

#### OpenFlowヘッダ

すべてのOpenFlowプロトコルのデータについてくるヘッダです。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| version (8)   | type (8)      | length (16)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| xid (32)                                                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

version
: OpenFlowプロトコルのバージョン

type
: OpenFlowヘッダのあとに続くペイロードの種類 (Hello, EchoRequest, FlowMod etc.)

length
: OpenFlowヘッダそのものも含めたフレーム長

xid
: トランザクションID

#### EchoRequestメッセージ

OpenFlowヘッダのあとにlengthからOpenFlowヘッダサイズ8オクテット
を引いた分のサイズを持つデータが続きます。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| version (8)   | type (8)      | length (16)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| xid (32)                                                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| arbitary-length data field                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

## 解析の考え方

先頭から固定長のフィールドを読んでいくのはとても簡単です。
AttoparsecのParserを素直に使えばいいだけです。

```haskell
version <- anyWord8
type_ <- anyWord8
length <- anyWord16
xid <- anyWord32
-- anyWord16とanyWord32は標準ではついていないので適当に自作します
```

問題は`arbitary-length data field`のところです。
可変長フィールドです。　

長さは事前に読み込んだ`length`から計算できます。
`length`はOpenFlowヘッダを含んだフレームの長さです。

```
length = OpenFlowヘッダ長(8) + ペイロードのデータ長
```

いま知りたいのはフレームからOpenFlowヘッダを除いた残りの部分のデータ長です。

```
ペイロードのデータ長 = length - OpenFlowヘッダ長(8)
```

なので`length - 8`が残りのフィールドの長さになります。
これをHaskellで書くとこんな感じです。Nオクテットのデータを`ByteString`として読み込む`take`を使います。

```haskell
payload <- take (length - 8)
```

あとはこのペイロードを解析すればいいだけです。

## 問題

*T.B.D.*
