+++
title = "プロセッサを支える技術"
date = 2016-07-13
aliases = ["/posts/note/2016-07-13-learning-processor-introduction.html"]
[taxonomies]
tags = ["reading"]
+++

[プロセッサを支える技術](https://www.amazon.co.jp/dp/4774145211/)

## はじめに

ぐわー難しい。登場人物が何かは説明されるので解るが、動作は文章だけではなかなか追えない。
特に全然理解できてないなと思うのは3章。もっともディープな解説がなされるところだが、そこが解ってないという体たらく……。
下記は特によく解ってない。

- キャッシュの3つの方式
- 演算器
- メモリアクセス

## パイプライン

基本的なパイプラインの構造はとても泥臭くて面白かった。
パイプラインを効率的に実行するための障害となるのが、

- 構造的ハザード
- データハザード
- 制御ハザード

### 構造的ハザード

パイプライン上の命令がハードウェア資源の競合を起こすこと。
メモリの書き込みと読み込み処理をする際に衝突するなど。

#### 解決

ハードウェアは増やしスーパースカラ化して命令処理を並列化する。

### データハザード

直前の命令がレジスタに書き込んだ演算結果を使って別の演算を行うような命令のデータ依存が発生すること。

#### 解決

Out-of-Orderにより命令の順序を一部的に組み替えて効率的に処理することでブロックする処理のコストを相殺する。

### 制御ハザード

条件分岐を行う処理において、条件判定が完了するまでは後続の`then`や`else`の命令をパイプライン実行できないこと。

#### 解決

条件判定の結果を統計として保存しておき、*確率の高い命令を予め実行する*分岐予測という手段がある。
見込みがはずれた場合はレジスタをロールバックさせる。

*T.B.D.*

## キャッシュ

*T.B.D.*

## 演算器

*T.B.D.*

## ページ方式

*T.B.D.*

## ARMかx86でアセンブリ言語FizzBuzz

*T.B.D.*

## メモ

### コモンバス

ルータの内部アーキテクチャに踏み入るとGrant,Requestという用語が出てくるが、
これがプロセッサと入出力をつなぐコモンバスの命令であることがわかった。

### x86はCISC?

x86命令はCISCよりの複雑な命令体系を持っているが、結局ハードがRISCっぽい命令に変換して
パイプランに送り込んでいるらしい。命令の構造が単純なRISCの方が効率いいね、という話になったのだろう。

### 回りくどいVMMへの委譲方法

VMMによる仮想化はゲストOSから特権命令を発行した時に発生する例外を捕まえてVMMにインターセプトさせるらしく
なんだかものすごく効率悪そうに感じた。イベント駆動っぽいので他のやり方よりももしや性能がいいという理由から選ばれているのかもしれない。
