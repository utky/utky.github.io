---
title = "BGP reading note"
date = 2016-03-13
aliases = ["/posts/note/2016-03-13-learning-bgp.html"]
[taxonomies]
tags = ["network","bgp"]
---

# BGPについて勉強する

まず大事なこと。
RIBはBGPの経路広告によって受信した経路のデータベースであるということ。

RIBをもとにベストパスの計算をおこなって自分のルーティングテーブルを生成するということ。

```
---> Adj RIB in ---> local RIB ---> Adj RIB out
                         | ^
                         | |
                         v |
                    Routing table
```

BGPの基本はBGPピアに対して任意の重みを付加した経路を広告すること。

その重みの中でもよく使いそうなのが

- Local Preference
- MED

### Local Preference

自ASのBGPピアに対して伝える経路の重み。
自ASから外に出て行く方向を決めるために使う。

逆に外のASには伝わらない。

### MED

隣接ASのBGPピアに対して伝える経路の重み。
外部ASから自ASへと流入する方向を決めるために使う。

AS-AとAS-Bの間に二つのASBRが接している場合、どちらのASBRを優先的に使ってもらって欲しいかを伝えるためにMEDの重みをつけて伝達する。
隣接ASであるAS-Bがそれを受け入れてその通りに経路制御してくれるとは限らない。

## iBGPの難しさ

iBGPは基本的にフルメッシュでピアを確立する必要がある。これには理由がある

iBGPは下記のようには動かない。

```
iBGP-A ---- UPDATE ----> iBGP-B ---- UPDATE ----> iBGP-C
```

つまりiBGPのピアから受信したUPDATEは別のピアへと転送されない。

実際はこう

```
iBGP-A ---- UPDATE ----> iBGP-B                   iBGP-C
```

ピアから受信したUPDATEは受信した先でとまる。

もし別のピアへとUPDATEが転送されてしまうと経路ループが発生するため。

各iBGPピアからの経路情報をもれなく受信するためにはiBGPピアをフルメッシュで組む必要がある。
これはASBRのスケーラビリティが低い。コネクションの数は下記の数になってしまうためだ。

```
n (n - 1) / 2
```

これを解決するための方法として

1. ルートリフレクタ
2. ASコンフェデーレーション

というアプローチがある。

### ルートリフレクタ

上記の問題を解決するためにBGPセッションを一つに集約するルートリフレクタをメッシュの中央に配置することで、
スター型のBGPトポロジができる。

### ASコンフェデレーション

またはiBGPのピアをさらに小さなプライベートASに分割した上でASコンフェデレーションを使って一つにまとめ上げる。

以前は前者の方がよいと思っていたが、分割統治の考え方からすると後者のASコンフェデの方が綺麗なきがする。

## OpenFlowとBGP

OpenFlowのメリットはC-planeとD-planeの分離だ。
この分離の考え方はもちろん他のプロトコルでも応用できる。

BGPは経路制御を担当するのでC-planeのプロトコルとなる。
対となるD-planeはIP。ルーティングテーブルの情報を使ってパケットをフォワーディングする。

このBGPのアーキテクチャをOpenFlowを使って分離するとこうなる。

- C-plane: BGP on OpenFlow controller
- D-plane: IP on OpenFlow switch

一台のBGPルータであればベストパスの選択が終わったらローカルなルーティングテーブルに書き込むだけで終わる。
OpenFlowのようにレイヤーが分離されたアーキテクチャではどうだろうか。
BGPをハンドルするcontrollerがローカルのDBに経路を保存する必要があるかもしれない。
さらにdatapathに対してそれらの経路を設定する必要がある。そのためにはBGPで生成された経路をOpenFlow
メッセージに変換datapathに投入する必要がある。

