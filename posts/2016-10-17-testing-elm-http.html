<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Hash λ Bye - [WIP]ElmのHttp処理部をスタブする</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css">

        <!-- <link rel="stylesheet" type="text/css" href="/css/pure-nr-min.css" /> -->
        <!-- <link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css" /> -->
        <!-- <link rel="stylesheet" type="text/css" href="/css/highlight.css"> -->
        <link rel="stylesheet" type="text/css" href="../css/default.css" />

    </head>
    <body>
        <nav>
          <div class="nav-wrapper indigo darken-1">
            <a href="../" class="brand-logo">Hash λ Bye</a>
            <ul class="right hide-on-med-and-down">
              <li>
                <a href="../">Home</a>
              </li>
              <li>
                <a href="../about.html"></i>About</a>
              </li>
              <li>
                <a href="../contact.html">Contact</a>
              </li>
              <li>
                <a href="../archive.html">Archive</a>
              </li>
            </ul>
          </div>
        </nav>

        <div id="content" class="container">
            <h1 class="title">[WIP]ElmのHttp処理部をスタブする</h1>

            <div class="body">
            <div class="info">
    Posted on October 17, 2016
    
</div>

<h2 id="問題">問題</h2>
<p>Elmでアプリケーション書いていると当然リモートのHTTP APIへリクエストを飛ばす部分がでてくる。 けれどチュートリアルの章を読むと<code>Http</code>パッケージへhard wireしてある。このポリシーに従ってそのまま実装していくと、 <code>elm-reactor</code>で動かした際に、APIのエンドポイントに本当にリクエストを飛ばしてしまう。</p>
<p>APIの実装がまだない場合や、テストでダミーのJSONを渡したい場合はこれだと困る。</p>
<h2 id="解法">解法</h2>
<p>なにか大仰なモックライブラリが必要か、とか悩んでしまったけど、簡単な話だった。</p>
<p>HTTPリクエスト処理部の関数だけ抜き出して、後から渡せるようにすればいい。つまり <strong>高階関数</strong> で解決する。 <code>Http</code>ライブラリを呼び出す関数またはダミー用データを返す関数、いずれかを後から注入する感じ。</p>
<ol style="list-style-type: decimal">
<li>HTTPリクエストを表すメッセージ用update</li>
<li>その他のイベントを表すメッセージ用update</li>
</ol>
<p>update関数を二つに分割する。というか、HTTPリクエスト処理部だけを別関数に分割する。</p>
<h2 id="サンプルケース">サンプルケース</h2>
<p>たとえば外部のAPIエンドポイントと通信して“Hello”という文字列を取り出してくることを考える。</p>
<h3 id="モデル">モデル</h3>
<p>外部から受け取った文字列を保存するだけのモデル。</p>
<pre class="elm"><code>type alias AppState = { out : String }

init : ( AppState, Cmd Msg )
init = ( { out = &quot;&quot; }, Cmd.none )</code></pre>
<h3 id="ビュー">ビュー</h3>
<p><code>say hello</code>ボタンを押すと<code>FetchHello</code>というメッセージをトリガする。 モデルが保持する文字列をテキストとして書き出す。</p>
<pre class="elm"><code>view : AppState -&gt; Html Msg
view model =
  div [ ]
      [ button
          [ onClick FetchHello ]
          [ text &quot;say hello&quot; ]
      , span
          []
          [ text model.out ]
      ]</code></pre>
<h3 id="メッセージ">メッセージ</h3>
<pre class="elm"><code>type Msg
  = FetchHello
  | GotHello String
  | FailHello Http.Error</code></pre>
<ul>
<li><code>FetchHello</code>: リモートAPIに“Hello”という文字列を送ってもらう要求。<strong>これの応答をスタブしたい</strong></li>
<li><code>GotHello</code>: 正常に文字列を受信した場合の応答。</li>
<li><code>FailHello</code>: 文字列を受信に失敗した場合の応答。</li>
</ul>
<h2 id="メッセージのハンドラ-update関数">メッセージのハンドラ: update関数</h2>
<pre class="elm"><code>update : Msg -&gt; AppState -&gt; ( AppState, Cmd Msg )
update msg model =
  case msg of
    FetchHello -&gt; -- 普通だったらここで Http.get とかやるけど。。。。
    GotHello s -&gt; { model | out = s } ! []
    FailHello e -&gt; { model | out = &quot;failure!&quot; } ! []</code></pre>
<p>ようやく改善したいポイントに到着。 ここにHTTPリクエストの発行を埋め込んでしまうと、呼び出し先のHTTP APIがどこかで起動している必要がある。 開発中は<code>elm-reactor</code>で気軽に動作確認したいのに、外部API呼び出しが走るのは避けたい。</p>
<p>そこだけ外から制御できるようにしよう。</p>
<pre class="elm"><code>update : Cmd Msg -&gt; Msg -&gt; AppState -&gt; ( AppState, Cmd Msg )
update cmd msg model =
  case msg of
    FetchHello -&gt; (model, cmd)
    GotHello s -&gt; { model | out = s } ! []
    FailHello e -&gt; { model | out = &quot;failure!&quot; } ! []</code></pre>
<p>テスト用と実際のAPI呼び出し用の関数を用意する。</p>
<pre class="elm"><code>-- | 実際に外部APIを呼び出してリモートからデータを受け取る
fetchHello : Cmd Msg
fetchHello =
  Http.get &quot;http://some.endpoint/hello&quot; string
    |&gt; Task.perform FailHello GotHello

-- | ダミーのデータを返す
dummyHello : Cmd Msg
dummyHello =
  Http.succeed &quot;Hello&quot;
    |&gt; Task.perform FailHello GotHello</code></pre>
<h2 id="雑感">雑感</h2>
<p>論旨とずれるけれど、Elmは少ないbuilding blocksと関数型プログラミングだけで本当にだいたいのことができてしまう。 MonadやFunctorなどの概念は一切出てこない（これは<a href="https://groups.google.com/forum/m/#!topic/elm-discuss/1acyOfxvasA">evancのポリシー</a>だと思う)</p>

            </div>
        </div>
        <footer>
          <div class="footer-copyright">
            <span class="right">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </span>
          </div>
        </footer>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['\\(','\\)']]},
          processEscape: true
        });
        </script>

        <!-- <script src='/js/highlight.pack.js'></script> -->
        <!-- <script>hljs.initHighlightingOnLoad();</script> -->
    </body>
</html>
