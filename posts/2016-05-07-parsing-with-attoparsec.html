<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Hash λ Bye - OpenFlowのメッセージをAttoparsecで解析する</title>
        <link rel="stylesheet" type="text/css" href="../css/pure-nr-min.css" />
        <link rel="stylesheet" type="text/css" href="../css/font-awesome.min.css" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlight.css">


    </head>
    <body>
        <div class="pure-menu pure-menu-horizontal">
          <a href="../" class="brand pure-menu-heading pure-menu-link">Hash λ Bye</a>
          <ul class="pure-menu-list">
            <li class="pure-menu-item">
              <a href="../" class="pure-menu-link">Home</a>
            </li>
            <li class="pure-menu-item">
              <a href="../about.html" class="pure-menu-link"></i>About</a>
            </li>
            <li class="pure-menu-item">
              <a href="../contact.html" class="pure-menu-link">Contact</a>
            </li>
            <li class="pure-menu-item">
              <a href="../archive.html" class="pure-menu-link">Archive</a>
            </li>
          </ul>
        </div>

        <div id="content">
            <h1 class="title">OpenFlowのメッセージをAttoparsecで解析する</h1>

            <div class="body">
            <div class="info">
    Posted on May 15, 2016
    
</div>

<h2 id="はじめに">はじめに</h2>
<p>最近OpenFlowをもう一度見直すべきではないか、という念がふつふつと湧いてきており、OpenFlowのメッセージのエンコード/デコードを行うプログラムをHaskellで書こうとしています。</p>
<p>この記事ではそのデコードに必要な解析器(parser)を作る上でのポイントをメモしておきます。</p>
<h3 id="先に結論">先に結論</h3>
<p>実際にparserを書いてみて解ったことは下記のとおり。</p>
<p><strong>1. 固定長フィールドは素直にAttoparsecのAPIを使えば解析できる</strong></p>
<p><strong>2. 可変長フィールドを解析するためには、事前に動的に変わるフィールドの長さを解析する</strong></p>
<p><strong>3. 可変長フィールドの中身は前もってまとめてByteStringとして読み込む</strong></p>
<p><strong>4. 読み込んだByteStringを使って一度parserを実行する</strong></p>
<p>残った疑問は下記のとおり。</p>
<p><strong>???: parserの中でparserを実行する以外にこの要求を実現する方法はないのだろうか?</strong></p>
<p>parser内でサブのparserを実行するというデザインに違和感を抱えた形になりました。 まだこれの代替デザインは見つかっていません。</p>
<h3 id="openflowのメッセージ用parserの特徴">OpenFlowのメッセージ用parserの特徴</h3>
<p>OpenFlowのフレームフォーマットは、<em>固定長フィールド+可変長フィールド</em>で構成されています。 JSONのように<code>{}</code>や<code>[]</code>など識別子を頼りに字句解析をするのではなく、フィールドの長さを頼りにデータを解析する必要があります。</p>
<p>市井のHaskellベースのparserを見ていると、フィールドの長さをベースにデータ解析をおこなう例があまり見当たりません(あってもWebSocket)。 多くの場合HTTPやJSON, SMTP, LDAPなどテキストから識別子を解析するプロトコルの実装です。固定長フィールド+可変長フィールドのフレーム解析はニーズが少ないせいか見かけません。</p>
<p>そうした固定長フィールド+可変長フィールドのフレーム解析にAttoparsecを使ってみて得られた、要点や注意点をお伝えできればと思います。</p>
<p>Javaのネットワークライブラリである<a href="http://netty.io/">Netty</a>にはこういうかゆいところに手が届く<a href="http://netty.io/4.0/api/io/netty/handler/codec/LengthFieldBasedFrameDecoder.html">API</a>があるんですよね。Nettyの成熟っぷりが凄まじい。</p>
<h2 id="ゴール">ゴール</h2>
<p>OpenFlowのEchoRequestメッセージの解析をゴールとします。</p>
<p>ここで示すコードではたまたまOpenFlowを使うだけで、あまりOpenFlowの機能や特徴に突っ込んだことは書きません。TLV形式のフレームフォーマットを見たことがある方ならご理解いただけると思います。</p>
<p>OpenFlowのハンドシェークシーケンスでは通常Helloメッセージの送受信が先にくるのですが、Helloはいつの間にか複雑になっていたので、ここでは書かないことにしました。</p>
<h2 id="openflow">OpenFlow</h2>
<p>OpenFlowはネットワークパケットが持つ様々なヘッダ情報をもとに「フロー」として分類し、フロー単位にスイッチングを行うOpenFlowスイッチを制御するためのプロトコルです。OpenFlowスイッチを制御するためのアプリケーションをOpenFlowコントローラと呼びます。</p>
<p>ここで想定しているのは<em>OpenFlow1.3</em>です。</p>
<h3 id="フレームフォーマット">フレームフォーマット</h3>
<p>解析するのに最低限必要なOpenFlowのフォーマットを記します。 ごく簡単なメッセージを例にとるので、さほど理解に苦しむことはない（はず）です。</p>
<p><strong>理解に苦しむところがあったら私の記述のせいなのでむしろご指摘ください。。。。</strong></p>
<h4 id="openflowヘッダ">OpenFlowヘッダ</h4>
<p>すべてのOpenFlowプロトコルのデータについてくるヘッダです。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| version (8)   | type (8)      | length (16)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| xid (32)                                                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>
<p>このヘッダでは「OpenFlowのどのバージョンのプロトコルか」や「そのあとにどんな種類のメッセージが続くか」を示します。</p>
<dl>
<dt>version</dt>
<dd>OpenFlowプロトコルのバージョン
</dd>
<dt>type</dt>
<dd>OpenFlowヘッダのあとに続くペイロードの種類 (Hello, EchoRequest, FlowMod etc.)
</dd>
<dt>length</dt>
<dd>OpenFlowヘッダそのものも含めたフレーム長
</dd>
<dt>xid</dt>
<dd>トランザクションID
</dd>
</dl>
<p><strong>今回は<code>type</code>フィールドは常に<code>EchoRequest(2)</code>を指すと考えてください。</strong></p>
<p>これをデータ型として定義すると下記のようになるでしょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OpenFlow</span>
  <span class="fu">=</span> <span class="dt">OpenFlow</span>
  { _<span class="ot">version ::</span> <span class="dt">Word8</span>
  , _<span class="ot">type    ::</span> <span class="dt">Word8</span>
  , _<span class="ot">length  ::</span> <span class="dt">Word16</span>
  , _<span class="ot">xid     ::</span> <span class="dt">Word32</span>
  }</code></pre></div>
<p>レコードのフィールド名に<code>_</code>がついているのは、予約語や関数名の衝突を避けるためです。</p>
<h4 id="echorequestメッセージ">EchoRequestメッセージ</h4>
<p><code>EchoRequest</code>はOpenFlowを喋るホスト同士での死活監視に利用されます。</p>
<p>OpenFlowヘッダのあとに任意の長さのデータが続くのが特徴です。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| version (8)   | type (8)      | length (16)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| xid (32)                                                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| arbitary-length data field                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>
<p><code>arbitary-length data field</code>がそのデータに相当します。 このデータがOpenFlowのメッセージ<code>EchoRequest</code>特有のフィールドになります。</p>
<p><code>EchoRequest</code>をヘッダに格納するために<code>OpenFlow</code>のデータ型をもう少し拡張します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OpenFlow</span>
  <span class="fu">=</span> <span class="dt">OpenFlow</span>
  { _<span class="ot">version ::</span> <span class="dt">Word8</span>
  , _<span class="ot">type    ::</span> <span class="dt">Word8</span>
  , _<span class="ot">length  ::</span> <span class="dt">Word16</span>
  , _<span class="ot">xid     ::</span> <span class="dt">Word32</span>
  , _<span class="ot">payload ::</span> <span class="dt">OpenFlowPayload</span> <span class="co">-- payloadをフィールドとして追加</span>
  }

<span class="co">-- payloadそのものの定義</span>
<span class="kw">data</span> <span class="dt">OpenFlowPayload</span>
  <span class="fu">=</span> <span class="dt">EchoRequest</span> { _<span class="ot">data ::</span> <span class="dt">ByteString</span> }</code></pre></div>
<p>データ型の定義ができました。バイナリーデータからこのデータ構造を出力するparser(解析器)を定義します。</p>
<h2 id="解析の進め方">解析の進め方</h2>
<p>前述のデータ構造<code>OpenFlow</code>を出力するparserを定義していきます。</p>
<p>ここではHaskellの<a href="https://hackage.haskell.org/package/attoparsec">Attoparsec</a>というライブラリを使います。</p>
<blockquote>
<p>A fast parser combinator library, aimed particularly at dealing efficiently with network protocols and complicated text/binary file formats</p>
</blockquote>
<p>とあるとおりネットワークプロトコルの解析に威力を発揮します。</p>
<h3 id="固定長フィールドの解析">固定長フィールドの解析</h3>
<p>先頭から固定長のフィールドを読んでいくのはとても簡単です。 AttoparsecのParserを素直に使えばいいだけです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">version_ <span class="ot">&lt;-</span> anyWord8
type_    <span class="ot">&lt;-</span> anyWord8
length_  <span class="ot">&lt;-</span> anyWord16
xid_     <span class="ot">&lt;-</span> anyWord32
<span class="co">-- anyWord16とanyWord32は標準ではついていないので適当に自作します</span></code></pre></div>
<p>こうすると到着したフレームの先頭から順次固定長フィールドを取り出すことができます。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| version (8)   | type (8)      | length (16)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| xid (32)                                                      | ← ここまでは読み込めました
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>
<p>この時点で残っているフィールドは可変長データのみになります。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| arbitary-length data field                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>
<h3 id="可変長フィールドの解析">可変長フィールドの解析</h3>
<p>ここは今までのように単純なparserを組み合わせるだけではダメそうです。 読み込むフィールドの長さが、今まで解析した結果に依存するからです。</p>
<p>読み込むフィールドの長さは事前に読み込んだ<code>length</code>から計算できます。 <code>length</code>はOpenFlowヘッダを含んだフレームの長さです。</p>
<pre><code>length = OpenFlowヘッダ長(8) + ペイロードのデータ長</code></pre>
<p>いま知りたいのはフレームからOpenFlowヘッダを除いた残りの部分のデータ長です。</p>
<pre><code>ペイロードのデータ長 = length - OpenFlowヘッダ長(8)</code></pre>
<p>なので<code>length - 8</code>が残りのフィールドの長さになります。 これをHaskellで書くとこんな感じです。Nオクテットのデータを<code>ByteString</code>として読み込む<code>take</code>を使います。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">payloadBytes <span class="ot">&lt;-</span> take (length_ <span class="fu">-</span> <span class="dv">8</span>)</code></pre></div>
<p>あとはこのペイロードを解析すればいいだけです。</p>
<h3 id="可変長データ用parserを実行する">可変長データ用parserを実行する</h3>
<p>上記の手順まで進むと、解決すべき残りの課題は</p>
<ul>
<li><strong>手元にある <code>payloadBytes :: ByteString</code> のみを使ってペイロードをparseする</strong></li>
</ul>
<p>になります。</p>
<p>これを満たす関数は</p>
<ul>
<li><code>parseOnly :: Parser a -&gt; ByteString -&gt; Either String a</code></li>
</ul>
<p>でしょう。 つまり一度parserの内部で別のparserを <strong>実行</strong> する必要があるのです。</p>
<h4 id="ペイロード用のparser">ペイロード用のparser</h4>
<p>ここでペイロードとはEchoRequestに付随する可変データ長フィールドです。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| arbitary-length data field                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>
<p>任意の長さのデータを取り出して<code>EchoRequest</code>のペイロードとするため下記のような定義になります。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">payloadParser ::</span> <span class="dt">Parser</span> <span class="dt">OpenFlowPayload</span>
payloadParser <span class="fu">=</span> <span class="dt">EchoRequest</span> <span class="fu">&lt;$&gt;</span> takeByteString</code></pre></div>
<p><code>takeByteString</code>は残りのデータを<code>ByteString</code>として読み込むparserです。</p>
<h4 id="ヘッダのparserとペイロードのparserを組み合わせる">ヘッダのparserとペイロードのparserを組み合わせる</h4>
<p>いままでのコードと合わせるとこんな感じになります。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 固定長フィールドはそのまま読み込む</span>
version_     <span class="ot">&lt;-</span> anyWord8
type_        <span class="ot">&lt;-</span> anyWord8
length_      <span class="ot">&lt;-</span> anyWord16
xid_         <span class="ot">&lt;-</span> anyWord32

<span class="co">-- 可変長フィールドを含んだデータを切り出す</span>
payloadBytes <span class="ot">&lt;-</span> take (length <span class="fu">-</span> <span class="dv">8</span>)

<span class="co">-- 1. 読み込んだpayloadBytesをもとにpayloadParserを実行する</span>
<span class="kw">case</span> parseOnly (payloadParser <span class="fu">&lt;*</span> endOfInput) payloadBytes <span class="kw">of</span>

  <span class="co">-- 2. Either String a が返却されるので中身を取り出す</span>
  <span class="co">--   3. 失敗した場合はエラーメッセージをParserの失敗として呼び出し元に知らせる</span>
  <span class="dt">Left</span> err     <span class="ot">-&gt;</span> fail err

  <span class="co">--   4. 成功した場合はそのデータを持つParserとして返却</span>
  <span class="dt">Right</span> payload <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">OpenFlow</span> version_ type_ length_ xid_ payload</code></pre></div>
<ol style="list-style-type: decimal">
<li><code>payload :: ByteString</code>とpayload解析用の<code>payloadParser</code>を<code>parseOnly</code>に渡す</li>
<li>返却される<code>Either String a</code>をパターンマッチで剥がして結果を取り出す</li>
<li><code>Left</code>によってエラーメッセージが返される場合は、それをparserの失敗とする</li>
<li><code>Right</code>によって<code>payload</code>の解析値が返される場合は、それを使って<code>OpenFlow</code>データを構築する</li>
</ol>
<h2 id="残った違和感">残った違和感</h2>
<p>これで固定長フィールド+可変長フィールドのデータを解析することができます。</p>
<p>ポイントは下記の通りです。</p>
<ul>
<li>事前に可変長フィールドの長さを解析・算出する</li>
<li>長さをもとに一度<code>ByteString</code>を取り出す</li>
<li>取り出した<code>ByteString</code>を使っていったんparserを実行する</li>
</ul>
<p>そして書いてみて解ったことがあります。</p>
<p><strong>このparserはちょっとスマートでない</strong></p>
<p>ような気がするということです。 理想としていたparserの作り方とずれているのです。</p>
<h4 id="理想のparserの作り方">理想のparserの作り方</h4>
<p>理想のparserの作り方とは</p>
<p><strong>parserを組み上げることに専念できる</strong></p>
<p>ような方法です。 parserを実行する方法については後で考えればいいのです。今はparserを組み合わせることだけに集中したい。そんな時、他のことを考えるのはノイズなのです。</p>
<p>HaskellのParser combinatorの良さは<em>小さなparserを組み合わせて大きなparserを作れる</em>ことです。 大きなparserを組み上げたら、あとは一回parserを実行すれば結果が得られます。</p>
<ol style="list-style-type: decimal">
<li>parserを組み合わせる</li>
<li>できあがったparserを実行する</li>
</ol>
<p>parserを書いているときには1に集中すればいいわけです。 そのparserをどう実行するかは1が終わってからじっくり考えてもいいのです。</p>
<p>それはとてもプログラマに優しい構成方法です。</p>
<h4 id="現実に出来上がったparser">現実に出来上がったparser</h4>
<p>でも今回作ったparserはちょっと違いました。</p>
<ol style="list-style-type: decimal">
<li>parserを組み合わせる</li>
<li>一度parserを実行して途中の結果を取り出す</li>
<li>結果をもとにparserを組み上げる</li>
<li>出来上がったparserを実行する</li>
</ol>
<p><em>2と3に余計なステップ</em>が入っています。 私はparserを組んでいるだけのはずなのに、何故かparserの実行方法について途中で時間を費やす必要があるのです。 これがノイズだと感じました。</p>
<p><em>私のparserの組み方が間違っているのではないか。</em> 何度もそう考えたのですが、まだ他の方法が見つかっていません。</p>
<p>いやーでも型検査は通っているし、テストはパスしているしまあいっか（雑） ってなりました。</p>
<p>そもそもそんな違和感を気にするべきなのでしょうか？ 実は大した問題じゃないのかもしれませんが、今の私はなんだか気になっています。</p>
<p>何かヒントになる論文が無いか探してます。</p>
<h2 id="まとめ">まとめ</h2>
<p>今回はネットワークから到着した<em>固定長フィールド+可変長フィールド</em>のフォーマットをもったOpenFlowメッセージをHaskellのAttoparsecで解析する方法について書いてみました。</p>
<p>解ったのは下記の4つのパターンです。</p>
<p><strong>1. 固定長フィールドは素直にAttoparsecのAPIを使えば解析できる</strong></p>
<p><strong>2. 可変長フィールドを解析するためには、事前に動的に変わるフィールドの長さを解析する</strong></p>
<p><strong>3. 可変長フィールドの中身は前もってまとめてByteStringとして読み込む</strong></p>
<p><strong>4. 読み込んだByteStringを使って一度parserを実行する</strong></p>
<p>残った疑問は下記のとおり。</p>
<p><strong>???: parserの中でparserを実行する以外にこの要求を実現する方法はないのだろうか?</strong></p>
<p>継続して勉強の必要がありそうです。菖蒲様のために六根清浄と叫んで己の士気をなんとか保っています。</p>
<p>何か解ったらまた更新したいと思います。</p>

            </div>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['\\(','\\)']]},
          processEscape: true
        });
        </script>

        <script src="../js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
